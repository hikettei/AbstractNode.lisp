
(cl:in-package :cl-user)

;; [TODO] SLEEF (Loop Collapse and ...), Vectorized Math

(defpackage :abstractnode.gcc-backend
  (:use :cl :AbstractNode.graph :AbstractNode.compiler))

(in-package :abstractnode.gcc-backend)

(defun merge-with (list key)
  (butlast
   (loop for l in list
	 append
	 `(,(format nil "~a" l) ,key))))

(defmethod compile-requirements ((backend-indicator (eql :gcc)))
  "
// Authmatically generated by AbstractNode.lisp
// DO NOT MODIFY THIS!
#include <sleef.h>
#include <omp.h>
"
  )

(defmethod compile-endline ((backend-indicator (eql :gcc))) ";")

(defmethod compile-aref ((backend-indicator (eql :gcc)) tensor index)
  (format nil "~a[~a]"
	  (tensor-memory-id tensor)
	  index))

(defmethod compile-symbol ((backend-indicator (eql :gcc)) symbol)
  ;; TODO: - -> _
  (format nil "~a" symbol))

(defmethod compile-dtype ((backend-indicator (eql :gcc)) dtype pointer-p)
  (symbol-macrolet ((dtype-helper 
		      (ecase dtype
			(:uint32
			 "uint32_t")
			(:double
			 "double")
			(:float
			 "float"))))
    (if pointer-p
	(format nil "~a *" dtype-helper)
	dtype-helper)))

(defmethod compile-iteration ((backend-indicator (eql :gcc))
			      index
			      from
			      to
			      by
			      body)
  (format nil "for (uint32_t ~a = ~a; ~a <= ~a; ~a++~a) { ~%~a~% }"
	  index
	  from
	  index
	  to
	  index
	  by
	  body))

(defmethod compile-function ((backend-indicator (eql :gcc))
			     name
			     vars
			     dynamic-shapes
			     body)
  (when (null body) (return-from compile-function ""))
  (with-output-to-string (out)
    (format out body)))

(macrolet ((def (op lisp-op)
	     `(defmethod compile-instruction
		  ((backend-indicator (eql :gcc))
		   (op                (eql ,op))
		   &rest args)
		(format nil "~a ~a" ,lisp-op (apply #'concatenate 'string (merge-with args " "))))))
  (def :+ "+")
  (def :- "-")
  (def :* "*")
  (def :/ "/")
  (def := "="))

(print
 (time
  (compile-with-backend
   :gcc
   (abop:lazy-add
    (abop:lazy-mul
     (make-tensor `(5 4 3) :float :input-p t)
     (make-tensor `(5 4 3) :float))
    (make-tensor `(5 4 3) :float)))))

